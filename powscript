#!/bin/bash
shopt compat40 2>&1 | grep invalid &>/dev/null && { echo "this app runs on bash >= 4.x, please upgrade"; exit 1;  }
{ 
  # enable strict bash 4.0 mode by disabling higher modes
  for mode in compat49 compat48 compat47 compat46 compat45 compat44 compat43 compat42 compat41; do shopt -u $mode; done
  shopt -s compat40
} &>/dev/null # hide errors of old 4.x versions
bash_settings='# Generated by POWSCRIPT (https://github.com/coderofsalvation/powscript)
#
# Unless you like pain: edit the .pow sourcefiles instead of this file

# powscript general settings
set -e                                # halt on error
set +m                                #
SHELL="$(echo $0)"                    # shellname
shopt -s lastpipe                     # flexible while loops (maintain scope)
shopt -s extglob                      # regular expressions
path="$(pwd)"
if [[ "$BASH_SOURCE" == "$0"  ]];then #
  SHELLNAME="$(basename $SHELL)"      # shellname without path
  selfpath="$( dirname "$(readlink -f "$0")" )"
  tmpfile="/tmp/$(basename $0).tmp.$(whoami)"
else
  selfpath="$path"
  tmpfile="/tmp/.dot.tmp.$(whoami)"
fi'
sh_settings='# Generated by POWSCRIPT (sh mode) (https://github.com/coderofsalvation/powscript)
#
# Unless you like pain: edit the .pow sourcefiles instead of this file

# powscript general settings
SHELL="$(echo $0)"                    # shellname
path="$(pwd)"'
settings="$bash_settings"
strictmode='shopt compat40 2>&1 | grep invalid &>/dev/null && { echo "this app runs on bash >= 4.x, please upgrade"; exit 1;  }
{ 
  # enable strict bash 4.0 mode by disabling higher modes
  for mode in compat49 compat48 compat47 compat46 compat45 compat44 compat43 compat42 compat41; do shopt -u $mode; done
  shopt -s compat40
} &>/dev/null # hide errors of old 4.x versions'
polyfill='# here comes a bash polyfill
# it tries to substitute missing bash commands 
# to provide somewhat compatibility in other shells like bin/sh

noop(){ 
  :>/dev/null
}

shopt(){ 
  noop       
}'
# Generated by POWSCRIPT (https://github.com/coderofsalvation/powscript)
#
# Unless you like pain: edit the .pow sourcefiles instead of this file

# powscript general settings
set -e                                # halt on error
set +m                                #
SHELL="$(echo $0)"                    # shellname
shopt -s lastpipe                     # flexible while loops (maintain scope)
shopt -s extglob                      # regular expressions
path="$(pwd)"
if [[ "$BASH_SOURCE" == "$0"  ]];then #
  SHELLNAME="$(basename $SHELL)"      # shellname without path
  selfpath="$( dirname "$(readlink -f "$0")" )"
  tmpfile="/tmp/$(basename $0).tmp.$(whoami)"
else
  selfpath="$path"
  tmpfile="/tmp/.dot.tmp.$(whoami)"
fi
declare -A footer
footer["async"]="
# wait for all async child processes (because \"await ... then\" is used in powscript)
[[ \$ASYNC == 1 ]] && wait
"

footer["tmpfile"]="
# cleanup tmp files
if ls /tmp/\$(basename \$0).tmp.$(whoami)* &>/dev/null; then
  for f in /tmp/\$(basename \$0).tmp.$(whoami)*; do rm \$f; done
fi
"
footer["zero_exit"]="exit 0
"
indent_current=0
indent_last=0
stack=()
anonymous_funcs=0
literal=0
last_keyword=""

getindent(){
  [[ ! ${1:0:1} =~ ([ \t]) ]] && echo 0 && return 0 
  echo "$1" | sed "s/\n/ /g" | awk '{ match($0, /^ */); printf("%d", RLENGTH) }' | sed 's/00/0/g'
}
  
add_anonymous_func(){
  anonymous_funcs=$((anonymous_funcs+1))
}

push (){ 
  var="$1"; shift 1; eval "$var+=($(printf "'%s' " "$@"))"; 
}

makeindent(){  
  for((i=0;i<$1;i++)); do printf " "; done
}

stack_pop(){
  index=${#stack[@]}
  index=$((index-1))
  [[ $index == "-1" ]] && return 0
  lastitem="${stack[$index]}"
  unset stack["$index"]
  [[ -n $IGNORE        ]] && return 0 
  [[ ${#lastitem} == 0 ]] && return 
  [[ $lastitem =~ "fi" ]] && [[ "$line" =~ "else" ]] && return 0  # if/else is a tricky one
  echo -e "$(makeindent $((indent_last-2)) )$lastitem"
  if ! (( (indent_last-2) == indent_current )); then 
    indent_last=$((indent_last-2))
    stack_pop "$1"
  fi
}

stack_update(){
  indent_last="$indent_current"
  indent_current=$(getindent "$1")
  [[ -n $DEBUG ]] && echo "\# debug: $indent_current|$indent_last|${#stack[@]} (indentlevel|last indentlevel|stackposition) "
  if ((indent_current < indent_last)); then stack_pop "$1"; fi
}

get_array_code(){
  printf '"'
  printf "\${$1[$2]}"
  printf '"'
}

transpile_all(){
  [[ -n $1 ]] && [[ $1 == '--noquotes' ]] && NO_QUOTES=1
  while IFS="" read -r line; do
    i=$(getindent "$line")
    [[ "$line" =~ ^(#)  ]] && local _comment="#"
    [[ "$line" =~ "={}" ]] && echo "$_comment$(makeindent $i)declare -A ${line/=\{\}/}" && continue
    [[ "$line" =~ "=[]" ]] && echo "$_comment$(makeindent $i)declare -a ${line/=\[\]/}" && continue
    [[ ! -n $NO_QUOTES  ]] && [[ ! "$line" =~ ([\'\"]\{) ]] && [[ "$line" =~ ([ ]\$[A-Za-z_0-9@]) ]] && line="$(echo "$line" | sed -E 's/([ =])\$([a-zA-Z_0-9@]+)/\1"$\2"/gi' )"
    echo "$line"
  done
}

transpile_for(){
  push stack "done"
  local semicolons="${1//[^;]}"
  local arr="$(echo "$1" | awk '{ print $4 }' )"
  local arr2nd="$(echo "$1" | awk '{ print $5 }' )"
  local i=$(( $(getindent "$code") + 2 ))
  args=""
  code="$1; do"
  indent="$(makeindent $i)"
  # traditional for loop
  if [[ ${#semicolons} == 2  ]]; then 
    code="${code/for /for (( }"
    code="${code/; do/ )); do}"
  # iterate over string (starts with $ or has more than 1 argument)
  elif [[ ${arr:0:1} =~ ^([$]) || ${#arr2nd} != 0 ]]; then 
    args="--noquotes"
  # iterate over associative array
  elif [[ "$code" =~ [a-zA-Z_0-9],[a-zA-Z_0-9] ]]; then
    local key="$(echo "$code" | awk '{ print $2 }' | awk -F',' '{ print $1 }')"
    local value="$(echo "$code" | awk '{ print $2 }' | awk -F',' '{ print $2 }')"
    code="$code\n$indent$value=$(get_array_code $arr "\$$key")"
    code="${code/,$value/}"
    code="${code/ of / in }"
    code="${code/ $arr/ $(get_array_code "!$arr" @)}";
  elif [[ ! "$arr" == "\$@" ]]; then
    # iterate over indexed array
    local key="$(echo "$code" | awk '{ print $2 }')"
    code="${code/ $arr/ $(get_array_code $arr @)}"
  fi
  echo -e "$code" | transpile_all ${args}
  last_keyword=for
}

transpile_while(){
  push stack "done"
  code="$(transpile_condition while "$1" "$2")"
  code="$code; do"
  echo "$code" | transpile_all
  last_keyword=while
}

transpile_if(){
  push stack "fi" 
  code="$(transpile_condition "if" "$1" "$2")"
  code="$code; then"
  echo "$code" | transpile_all
  last_keyword=if
}

transpile_else(){
  local curindent=$(getindent "$1")
  curindent=$(( curindent+2 ))
  local indent="$(makeindent $curindent)"
  local indent="$(makeindent $curindent)"
  [[ $last_keyword == "else" ]] && echo "$indent""fi"
  echo -e "$1"
  [[ $last_keyword == "else" ]] || push stack "fi"
  last_keyword=else
}

transpile_condition(){
  form=$1
  code="${2/$form not/$form !}"
  firstvar="${code/\! /}"
  firstvar="$(echo "$firstvar" | awk '{ print $2 }')"
  code="${code// and / && }"
  code="${code// or / || }"
  code="${code//> /-gt }"
  code="${code//>= /-ge }"
  code="${code//< /-lt }"
  code="${code//<= /-le }"
  code="${code//!= /-ne }"
  [[ "$code" =~ ($form[ ]) && "$firstvar" =~ ^([\"\$-]) ]] && code="${code/$form /$form [[ }"
  code="${code/match /=~ }"
  [[ "$code" =~ "[[" ]] && code="$code ]]"
  code="${code// is / == }"
  echo "$code"
}

transpile_then(){
  cmd="${*/await /}"
  cmd="$(echo "$cmd" | sed "s/'/\"/g")" # ugly hack..*FIXME*
  [[ ! -n $3 ]] && category="then" || category="$3"
  add_anonymous_func 
  funcindex=$anonymous_funcs
  echo -e "\n# async code"
  echo "_"$category"_$funcindex(){"
  local curindent=$(getindent "$1")
  local indent="$(makeindent $curindent)"
  if [[ $category =~ "pipe" ]]; then
    add_anonymous_func
    push stack "}\n$indent""async_$category _then_when_done_$anonymous_funcs "_"$category"_"$funcindex ${cmd/ then*/}"
    push stack ""
  else
    push stack "}\n$indent""async_$category "_"$category"_"$funcindex ${cmd/ then/}"
  fi
}

transpile_when_done(){
  local curindent=$(getindent "$1")
  echo -e "}\n_then_when_done_"$anonymous_funcs"(){"
}

transpile_switch(){
  push stack "esac"
  echo "${1/switch/case} in" 
  last_keyword=switch
}

transpile_case(){
  push stack "  ;;"
  echo "${1/case /})"
}

transpile_array_push(){
  code="${1/+=/+=(}"
  echo "$code)"
}

transpile_array_get(){
  postfix=${1/*\]/}
  code="${1/\]*/}]"
  code="${code/\$/\"\${}"
  code="${code/\]/]}}\""
  echo "$code""$postfix"
}

transpile_foreachline_from(){
  file="${1/[ ]?for line from /}"
  local curindent=$(getindent "$1")
  local indent="$(makeindent $curindent)"
  echo "$indent""while IFS=\"\" read -r line; do"
  push stack $indent"done < $file"
  last_keyword=foreachline
}

transpile_function(){
  push stack "}"
  local curindent=$(( $(getindent "$1") + 2 ))
  local indent="$(makeindent $curindent)"
  fields="${1//*\(/}"
  fields="${fields//\)*/}"
  fields="${fields// /}"
  fields="${fields//,/ }"
  echo "${1//\(*\)/()}{"
  local i=1; 
  for field in $fields; do echo "$indent""local $field=\"\${$i}\""; i=$((i+1)); done
  last_keyword=function
}

is_even(){
  a=$1
  [[ $((a%2)) -eq 0  ]] && return 0 || return 1
}

get_quotes_in_line(){
  quotes="${1//[^\'\"]}"
  echo ${#quotes}
}

is_quote(){
  [[ "$1" =~ ([\"\']) ]] && return 0 || return 1
}

line_is_multistring(){
  line="$1"
  i=$((${#line}-1))
  lastchar="${line:$i:1}"
  quotes=$(get_quotes_in_line "$line")
  (( $quotes == 1 )) && return 0
  (( $quotes == 0 )) && return 1
  is_even $quotes && return 1
  [[ "$line" =~ ([]a-zA-Z_0-9]=\"|[]a-zA-Z_0-9]=\') ]] && return 0
  return 1 # TODO: strip first line
}

check_literal(){
  local line="${1/ # */}"
  if line_is_multistring "$line"; then 
    if (( literal == 0 )); then 
      literal=1
    else
      literal=0
    fi
  fi
}
######################### begin-of-powscript-functions
powfunctions="async_pipe async_pipe_each_line async_then compose empty filter isset json_decode keys last map mappipe math on pick values"
# async_then <done_callback> <pipe_function> <function> <args..>
async_pipe() {
  cb=$1   ; shift
  pcb=$1  ; shift
  func=$1 ; shift
  { set +e; $func "$@" | $pcb; $cb $?; }&
  ASYNC=1
}
# async_then <done_callback> <pipe_line_function> <function> <args..>
async_pipe_each_line() {
  cb=$1   ; shift
  pcb=$1  ; shift
  func=$1 ; shift
  { 
    set +e
    $func "$@" | while IFS='' read line; do 
      $pcb "$line"
    done; 
    $cb $?
  }&
  ASYNC=1
}
# async_then <done_callback> <function> <args..>
async_then() {
  {
    set +e
    done="$1";  shift ; "$@" 
    $done $? # callback
  }&
  ASYNC=1
}
# compose function out of 2 functions
# example: 
#   compose functionname func2 func1
#   functionname "this is input"
compose() {
  result_fun=$1; shift ; f1=$1; shift ; f2=$1; shift
  eval "$result_fun() { $f1 \"\$($f2 \"\$*\")\"; }"
}
# example: empty "" && echo "empty string"
empty(){
  [[ "${#1}" == 0 ]] && return 0 || return 1
}
# usage: filter foo myfunc
filter(){
  map $1 | pipemap $2 
}
# example: isset "" && echo "not empty string" || echo "empty string"
isset(){
  [[ ! "${#1}" == 0 ]] && return 0 || return 1
}
# usage: echo '{"foo":"bar"}' | json_tokenize | json_parse

json_decode(){

  throw () {
    echo "json: $*" >&2
    exit 1
  }

  BRIEF=0
  LEAFONLY=0
  PRUNE=0

  awk_egrep () {
    local pattern_string=$1

    gawk '{
      while ($0) {
        start=match($0, pattern);
        token=substr($0, start, RLENGTH);
        print token;
        $0=substr($0, start+RLENGTH);
      }
    }' pattern=$pattern_string
  }

  json_tokenize () {
    local GREP
    local ESCAPE
    local CHAR

    if echo "test string" | egrep -ao --color=never "test" &>/dev/null
    then
      GREP='egrep -ao --color=never'
    else
      GREP='egrep -ao'
    fi

    if echo "test string" | egrep -o "test" &>/dev/null
    then
      ESCAPE='(\\[^u[:cntrl:]]|\\u[0-9a-fA-F]{4})'
      CHAR='[^[:cntrl:]"\\]'
    else
      GREP=awk_egrep
      ESCAPE='(\\\\[^u[:cntrl:]]|\\u[0-9a-fA-F]{4})'
      CHAR='[^[:cntrl:]"\\\\]'
    fi

    local STRING="\"$CHAR*($ESCAPE$CHAR*)*\""
    local NUMBER='-?(0|[1-9][0-9]*)([.][0-9]*)?([eE][+-]?[0-9]*)?'
    local KEYWORD='null|false|true'
    local SPACE='[[:space:]]+'

    $GREP "$STRING|$NUMBER|$KEYWORD|$SPACE|." | egrep -v "^$SPACE$"
  }

  parse_array () {
    local index=0
    local ary=''
    read -r token
    case "$token" in
      ']') ;;
      *)
        while :
        do
          parse_value "$1" "$index"
          index=$((index+1))
          ary="$ary""$value" 
          read -r token
          case "$token" in
            ']') break ;;
            ',') ary="$ary," ;;
            *) throw "EXPECTED , or ] GOT ${token:-EOF}" ;;
          esac
          read -r token
        done
        ;;
    esac
    [ "$BRIEF" -eq 0 ] && value=`printf '[%s]' "$ary"` || value=
    :
  }

  parse_object () {
    local key
    local obj=''
    read -r token
    case "$token" in
      '}') ;;
      *)
        while :
        do
          case "$token" in
            '"'*'"') key=$token ;;
            *) throw "EXPECTED string GOT ${token:-EOF}" ;;
          esac
          read -r token
          case "$token" in
            ':') ;;
            *) throw "EXPECTED : GOT ${token:-EOF}" ;;
          esac
          read -r token
          parse_value "$1" "$key"
          obj="$obj$key:$value"        
          read -r token
          case "$token" in
            '}') break ;;
            ',') obj="$obj," ;;
            *) throw "EXPECTED , or } GOT ${token:-EOF}" ;;
          esac
          read -r token
        done
      ;;
    esac
    [ "$BRIEF" -eq 0 ] && value=`printf '{%s}' "$obj"` || value=
    :
  }

  parse_value () {
    local jpath="${1:+$1,}$2" isleaf=0 isempty=0 print=0
    case "$token" in
      '{') parse_object "$jpath" ;;
      '[') parse_array  "$jpath" ;;
      # At this point, the only valid single-character tokens are digits.
      ''|[!0-9]) throw "EXPECTED value GOT ${token:-EOF}" ;;
      *) value=$token
         isleaf=1
         [ "$value" = '""' ] && isempty=1
         ;;
    esac
    [ "$value" = '' ] && return
    [ "$LEAFONLY" -eq 0 ] && [ "$PRUNE" -eq 0 ] && print=1
    [ "$LEAFONLY" -eq 1 ] && [ "$isleaf" -eq 1 ] && [ $PRUNE -eq 0 ] && print=1
    [ "$LEAFONLY" -eq 0 ] && [ "$PRUNE" -eq 1 ] && [ "$isempty" -eq 0 ] && print=1
    [ "$LEAFONLY" -eq 1 ] && [ "$isleaf" -eq 1 ] && \
      [ $PRUNE -eq 1 ] && [ $isempty -eq 0 ] && print=1
    [ "$print" -eq 1 ] && printf "[%s]\t%s\n" "$jpath" "$value"
    :
  }

  json_parse () {
    read -r token
    parse_value
    read -r token
    case "$token" in
      '') ;;
      *) throw "EXPECTED EOF GOT $token" ;;
    esac
  }

  varname="$1"
  code="$code$( sed 'N;s/\n//g' | json_tokenize | json_parse | awk '{print "'$varname'"$0}')"
  code="$(echo -e "$code" | sed  's/.*\[\].*//g;s/\t/=/g;s/",/./g;s/[,.]"/./g;s/.*=[{\[].*//g;s/\"\]=/]=/g;s/\]=/"\]=/g' | sed -r 's/([A-Za-z_0-9])([\.-])([A-Za-z_0-9])"]/\1-\3"]/g' )"
  eval "$code"
} 
# example: foreach foo keys
keys(){
  echo "$1"
}
last(){
  [[ ! -n $1 ]] && return 1 
  echo "$(eval "echo \${$1[@]:(-1)}")"
}
# maps a pipe stream to individual calls
# example:
#  map foo somefunction
map(){
  local arr="$1"; shift; local func="$1"; shift;
  eval "for i in \"\${!$arr[@]}\"; do $func \"\$@\" \"\$i\" \"\${$arr[\$i]}\"; done"
}
mappipe(){
  func="$1"; shift
  ( while read -r line; do $func "$@" "$line"; done )
}
math(){
  if [[ -n "$2" ]]; then
    which bc &>/dev/null && { echo "scale=$2;$1" | bc; } || echo "bc is not installed"; 
  else echo $(($1)); fi
}
#  1) SIGHUP	 2) SIGINT	 3) SIGQUIT	 4) SIGILL	 5) SIGTRAP
#  6) SIGABRT	 7) SIGBUS	 8) SIGFPE	 9) SIGKILL	10) SIGUSR1
# 11) SIGSEGV	12) SIGUSR2	13) SIGPIPE	14) SIGALRM	15) SIGTERM
# 16) SIGSTKFLT	17) SIGCHLD	18) SIGCONT	19) SIGSTOP	20) SIGTSTP
# 21) SIGTTIN	22) SIGTTOU	23) SIGURG	24) SIGXCPU	25) SIGXFSZ
# 26) SIGVTALRM	27) SIGPROF	28) SIGWINCH	29) SIGIO	30) SIGPWR
# 31) SIGSYS	34) SIGRTMIN	35) SIGRTMIN+1	36) SIGRTMIN+2	37) SIGRTMIN+3
# 38) SIGRTMIN+4	39) SIGRTMIN+5	40) SIGRTMIN+6	41) SIGRTMIN+7	42) SIGRTMIN+8
# 43) SIGRTMIN+9	44) SIGRTMIN+10	45) SIGRTMIN+11	46) SIGRTMIN+12	47) SIGRTMIN+13
# 48) SIGRTMIN+14	49) SIGRTMIN+15	50) SIGRTMAX-14	51) SIGRTMAX-13	52) SIGRTMAX-12
# 53) SIGRTMAX-11	54) SIGRTMAX-10	55) SIGRTMAX-9	56) SIGRTMAX-8	57) SIGRTMAX-7
# 58) SIGRTMAX-6	59) SIGRTMAX-5	60) SIGRTMAX-4	61) SIGRTMAX-3	62) SIGRTMAX-2
# 63) SIGRTMAX-1	64) SIGRTMAX	

on() {
    func="$1" ; shift
    for sig ; do
        trap "$func $sig" "$sig"
    done
}

#trap_with_arg func_trap INT TERM EXIT
# example: pick foo "index"
pick(){                                                                         
  [[ ! -n $2 ]] && return 1 
  local output="$(eval "echo \${$1[$2]}")"
  [[ ! ${#output} == 0 ]] && echo "$output" 
}
# example: foreach foo values
values(){
  echo "$2"  
}
######################### end-of-powscript-functions
# parse args
POW_VERSION=1.1
date=$(date +%Y%m%d%H%M%S)
rand=$(cat /dev/urandom | tr -cd [:alnum:] | head -c 4)
ID=$date"_"$rand
includefuncs=""
requires=""
tmpfile="/tmp/.$(whoami).pow.$date_$rand"
selfpath="$( dirname "$(readlink -f "$0")" )"
ps1="${PS1//\\u/$USER}"; p="${p//\\h/$HOSTNAME}"
evalstr=""
evalstr_cache=""
shopt -s extglob
shopt -s compat40
[[ -n $runtime ]] && runtime=$runtime || runtime=bash

input=$1
if [[ ! -n $startfunction ]]; then 
  startfunction=runfile
fi

empty "$1" && {
  echo 'Usage:
    
   powscript <file.pow>                                     run powscript directly                        
   powscript --compile [--sh] [--sourceable] <file.pow>     compile to bash [or (experimental) POSIX sh] [sourceable output] 
   powscript --lint <file.pow>                              crude linter                                  
   powscript --evaluate <powscript string>                  run powscript string directly                 
   powscript --interactive                                  interactive console                            
   echo <powscript string> | PIPE=1 powscript --compile     output bashcode                               
   echo <powscript string> | PIPE=1 powscript --evaluate    run bashcode                                  
   cat foo.bash            | powscript --tosh > foo.sh      convert bash to sh (experimental)             

   powscript --test <dir> && echo "OK"                      testsuite mode: run all *.pow files in dir recursively 
                                                                                                          
                                                                                                          
   note: PIPE=1 allows input from stdin, PIPE=2 as well   ┌─────────────────────────────────────────────────────┐
   but without the fat (no header/footercode)             │ powscript version '$POW_VERSION'                               │
                                                          │ docs: https://github.com/coderofsalvation/powscript │
  ';
}

for arg in "$@"; do
  case "$arg" in
    --sh)
      runtime=sh
      settings="$sh_settings"
      shift
      ;;
    --sourceable)
      noheaderfooter=1
      shift
      ;;
    --tosh)
      startfunction=tosh
      shift
      ;;
    --interactive)
      startfunction="console process"
      shift
      ;;
    --evaluate)
      startfunction=evaluate
      shift
      ;;
    --lint)
      startfunction=lint
      shift
      ;;
    --compile) 
      startfunction=compile
      shift
      ;;
    --test) 
      startfunction=testdir
      shift
      ;;
  esac
done

transpile_sh(){
  if [[ $runtime == "bash" ]]; then 
    cat
  else
    cat                                             \
      | sed "s/\[\[/\[/g;s/\]\]/\]/g"               \
      | sed "s/ == / = /g"                          \
      | sed "s/\&>\(.*[^;]\)[; $]/1>\1 2>\1; /g"    \
      | transpile_all                               
  fi
}

transpile_sugar(){
  while IFS="" read -r line; do 
    line="${line%"${line##*[![:space:]]}"}" # remove trailing whitespace
    check_literal "$line"  # this will flip literal to 0 or 1 in case of multiline literal strings
    if [[ $literal == 0 ]]; then
      stack_update "$line"
      [[ "$line" =~ ^(require |require_cmd|#)            ]] && continue
      [[ "$line" =~ ^([ ]*else$)                         ]] && transpile_else "$line"                       && continue
      [[ "$line" =~ (\$[a-zA-Z_0-9]*\[)                  ]] && transpile_array_get "$line"                  && continue
      [[ "$line" =~ ^([ ]*for line from )                ]] && transpile_foreachline_from "$line"           && continue
      [[ "$line" =~ ^([ ]*for )                          ]] && transpile_for "$line"                        && continue
      [[ "$line" =~ ^([ ]*when done)                     ]] && transpile_when_done "$line"                  && continue
      [[ "$line" =~ ^([ ]*await .* then for line)        ]] && transpile_then "$line" "pl" "pipe_each_line" && continue
      [[ "$line" =~ ^([ ]*await .* then \|)              ]] && transpile_then "$line" "p"  "pipe"           && continue
      [[ "$line" =~ ^([ ]*await .* then)                 ]] && transpile_then "$line"                       && continue
      [[ "$line" =~ ^([ ]*if )                           ]] && transpile_if  "$line"                        && continue
      [[ "$line" =~ ^([ ]*switch )                       ]] && transpile_switch "$line"                     && continue
      [[ "$line" =~ ^([ ]*while )                        ]] && transpile_while "$line"                      && continue
      [[ "$line" =~ ^([ ]*case )                         ]] && transpile_case "$line"                       && continue
      [[ "$line" =~ ([a-zA-Z_0-9]\+=)                    ]] && transpile_array_push "$line"                 && continue
      [[ "$line" =~ ^([a-zA-Z_0-9:\.]*\([a-zA-Z_0-9, ]*\)) ]] && transpile_function "$line"                   && continue
      echo "$line" | transpile_all
    else 
      echo "$line"
    fi
  done <  "$1"
  stack_update ""
}

cat_requires(){
  while IFS="" read -r line; do 
    if [[ "$line" =~ ^(require_cmd ) ]]; then                                           # include require_cmd dependency checks
      local cmd="${line//*require_cmd /}"; cmd="${cmd//[\"\']/}"
      printf "%-30s %s\n" "which $cmd &>/dev/null" "|| { echo \"dependency error: it seems '$cmd' is not installed (please install it)\"; }"
    fi
    if [[ "$line" =~ ^(require ) ]]; then                                               # include require-calls
      local file="${line//*require /}"; file="${file//[\"\']/}"
      if [[ ! -f $file ]]; then echo "echo 'compile error: couldn't find required file: $file'; exit 1;"; exit 1; fi
      echo -e "#\n# $line (included by powscript\n#\n"
      cat "$file";
    fi
  done < "$1"
}

transpile_functions(){
  # *FIXME* this is bruteforce: if functionname is mentioned in textfile, include it
  declare -A seen
  local allfuncs="(${powfunctions// /|})"
  local anydel="\\\'\\\\\" "
  local odel="\\\($anydel" # open delimiters
  local cdel="\\\)$anydel" # close delimiters
  local nodel="[^\\\(\\\)$anydel]"
  local namechar='[a-zA-Z0-9_-]'
  local startsname='(?<!'"${namechar}"')'
  local endsname='(?!'"${namechar}"')'
  local regex="[$odel]?${startsname}$allfuncs${endsname}[$cdel]?"
  while IFS="" read -r line; do
    matched_funcs="$(echo "$line" | grep -oP "$regex" | grep -oP "($nodel)+" || printf '')"
    for func in $matched_funcs; do
       if [[ ${seen["$func"]} != true ]]; then
         includefuncs="$includefuncs $func";
         seen[$func]=true
       fi
    done;
  done < "$1"
  [[ ! ${#includefuncs} == 0 ]] && echo -e "#\n# generated by powscript (https://github.com/coderofsalvation/powscript)\n#\n"
  for func in $includefuncs; do 
    declare -f $func; echo ""; 
  done
}

compile(){
  if [[ -n $PIPE ]]; then 
    cat | lint_pipe > $tmpfile
  else
    local dir="$(dirname "$1")"; local file="$(basename "$1")"; cd "$dir" &>/dev/null
    { cat_requires "$file" ; echo -e "#\n# application code\n#\n"; cat "$file"; } | lint_pipe > $tmpfile
  fi
  [[ ! $PIPE == 2 ]] && {
    echo -e "#!/bin/$runtime\n"
    [[ ! $runtime == "bash" ]] && echo -e "$polyfill"
    echo -e "$settings"
  }
  transpile_sugar "$tmpfile" | grep -v "^#" > $tmpfile.code
  sed -i 's/\\#/#/g' $tmpfile.code
  transpile_functions $tmpfile.code
  {
    cat $tmpfile.code
    [[ ! $PIPE == 2 && ! -n $noheaderfooter ]] && for i in ${!footer[@]}; do echo "${footer[$i]}"; done 
  } | transpile_sh
}


process(){
  evalstr="$evalstr\n""$*"
  if  [[ ! "$*" =~ ^([A-Za-z_0-9]*=) ]]  && \
      [[ ! "$*" =~ \)$ ]]                && \
      [[ ! "$*" =~ ^([ ][ ]) ]]; then 
    evaluate "$evalstr"
  fi
}

evaluate(){
  [[ -n $PIPE ]] && cat > $tmpfile || echo -e "$*" | lint_pipe > $tmpfile
  evalstr_cache="$evalstr_cache\n$*"
  [[ -n $DEBUG ]] && echo "$(transpile_sugar $tmpfile)"
  eval "$(transpile_sugar $tmpfile)"
  evalstr=""
}

tosh(){
  runtime=sh
  transpile_sh
}

edit(){
  local file=/tmp/$(whoami).pow
  echo -e "#!/usr/bin/env powscript$evalstr_cache" | grep -vE "^(edit|help)" > $file && chmod 755 $file
  $EDITOR $file
}

help(){
  echo '
  FUNCTION                  foo(a,b)
                              switch $a
                                case [0-9])
                                  echo 'number!'
                                case *)
                                  echo 'anything!'

  IF-STATEMENT              if not $j is "foo" and $x is "bar"
                              if $j is "foo" or $j is "xfoo"
                                if $j > $y and $j != $y or $j >= $y
                                  echo "foo"
  
  READ FILE BY LINE         for line from $selfpath/foo.txt
                              echo "->"$line

  REGEX                     if $f match ^([f]oo)
                              echo "foo found!"    

  MAPPIPE                   myfunc()
                              echo "line=$1"

                            echo -e "foo\nbar\n" | mappipe myfunc
                            # outputs: 'value=foo' and 'value=bar'

  MATH                      math '9 / 2'
                            math '9 / 2' 4
                            # outputs: '4' and '4.5000'
                            # NOTE: the second requires bc 
                            # to be installed for floatingpoint math

  ASYNC                     myfunc()
                              sleep 1s
                              echo "one"

                            await myfunc 123 then
                              echo "async done"

                            # see more: https://github.com/coderofsalvation/powscript/wiki/Reference

  CHECK ISSET / EMPTY       if isset $1
                              echo "no argument given"
                            if not empty $1
                              echo "string given"
  
  ASSOC ARRAY               foo={}
                            foo["bar"]="a value"

                            for k,v in foo
                                echo k=$k
                                  echo v=$v
                                    
                                  echo $foo["bar"]

  INDEXED ARRAY             bla=[]
                            bla[0]="foo"
                            bla+="push value"

                            for i in bla
                                echo bla=$i

                                echo $bla[0]


  SOURCE POWSCRIPT FILE     require foo.pow

  SOURCE BASH FILE          source foo.bash

  see more at: https://github.com/coderofsalvation/powscript/wiki/Reference
  
  ' | less
}

lint(){
  cat "$1" | lint_pipe
}

lint_pipe(){
  code="$(cat)"
  output="$(echo "$code" | awk -F"[  ]" '{ j=0; for(i=1;i<=NF && ($i=="");i++); j++; if( ((i-1)%2) != 0 ){ print "indent error: "$j" "$i; }  }')"
  if [[ ${#output} != 0 ]]; then 
    echo "$output" 1>&2
    exit 1
  else
    echo "$code"
    return 0
  fi
}

console(){
  echo "hit ctrl-c to exit powscript, type 'edit' to launch editor, and 'help' for help"
  while IFS="" read -r -e -d $'\n' -p "> " line; do
    "$1" "$line" || [[ $? =~ (0|1|2|3|13|15) ]]
    history -s "$line"
  done
}

runfile(){
  file=$1; shift;
  eval "$(compile "$file")"
}

testdir(){
  find -L "$1" -maxdepth 15 -name "*.pow"  > $tmpfile.test
  find -L "$1" -maxdepth 15 -name "*.bash" >> $tmpfile.test
  {
    ntest=0
    error=0
    C_FILE="\033[1;34m"
    C_DEFAULT="\033[0;00m"
    C_INFO="\033[1;32m"
    C_ERROR="\033[1;31m"
    _print(){
      local C="$2"
      printf "${C}$1\n${C_DEFAULT}"
    }
    while IFS="" read test; do
      _print "▶ $test\n" "$C_FILE"
      if [[ "$test" =~ ".pow" ]]; then
        $selfpath/powscript $test 2>&1 || error=$((error+1))
      else
        [[ -x $test ]] && $test 2>&1 || error=$((error+1))
      fi
      echo ""
    done < $tmpfile.test 
    (( error > 0 )) && C="$C_ERROR" || C="$C_INFO"
    _print "▶ ERRORS: $error\n\n" "$C"
  } | awk '{ if( $0~/▶/ ){ print $0; }else{ print "    "$0; } }'
  exit $error
}

${startfunction} "$@" #"${0//.*\./}"
retcode=$?

for tmpf in "$tmpfile"*; do
  rm "$tmpf"
done

exit $retcode
